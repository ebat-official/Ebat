generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["fullTextSearchPostgres"]
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

enum UserRole {
  ADMIN
  USER
}

enum SubscriptionPlan {
  BASIC
  PREMIUM
}

enum AccountStatus {
  ACTIVE
  INACTIVE
  SUSPENDED
}

enum VoteType {
  UP
  DOWN
}

enum PostType {
  BLOGS
  QUESTION
  CHALLENGE
  SYSTEMDESIGN
}

enum Difficulty {
  EASY
  MEDIUM
  HARD
}

enum PostCategory {
  FRONTEND
  BACKEND
  ANDROID
}

enum PostStatus {
  DRAFT
  PUBLISHED
}

enum PostApprovalStatus {
  PENDING
  APPROVED
  REJECTED
}

enum SubCategory {
  JAVASCRIPT
  HTML
  CSS
  REACT
}

model User {
  id               String             @id @default(uuid()) @db.Uuid
  email            String             @unique
  userName         String?            @unique
  password         String?
  emailVerified    DateTime?
  accounts         Account[]
  role             UserRole           @default(USER)
  accountStatus    AccountStatus      @default(ACTIVE)
  createdAt        DateTime           @default(now())
  updatedAt        DateTime           @updatedAt
  karmaPoints      Int                @default(0)
  coins            Int                @default(0)
  userProfile      UserProfile?       @relation("UserToProfile")
  lastLoginAt      DateTime?
  Post             Post[]
  collaborators    Post[]             @relation("PostCollaborators")
  Comment          Comment[]
  Vote             Vote[]
  CommentVote      CommentVote[]
  CommentMention   CommentMention[]
  CompletionStatus CompletionStatus[]
  following        Follow[]           @relation("Following") // Users the user follows
  followers        Follow[]           @relation("Followers") // Users who follow this user
  Bookmark         Bookmark[]
  Report           Report[]
  Notification     Notification[]
}

model UserProfile {
  id               String           @id @default(uuid()) @db.Uuid
  userId           String           @unique @db.Uuid
  name             String?
  email            String           @unique
  jobTitle         String?
  description      String?
  companyName      String?
  phoneNumber      String?
  image            String?
  coverImage       String?
  location         String?
  subscriptionPlan SubscriptionPlan @default(BASIC)
  externalLinks    Json?
  user             User             @relation("UserToProfile", fields: [userId], references: [id], onDelete: Cascade)
}

model Follow {
  id         String   @id @default(uuid()) @db.Uuid
  followerId String   @db.Uuid
  followedId String   @db.Uuid
  createdAt  DateTime @default(now())

  follower User @relation("Followers", fields: [followerId], references: [id], onDelete: Cascade)
  followed User @relation("Following", fields: [followedId], references: [id], onDelete: Cascade)

  @@unique([followerId, followedId]) // Prevent a user from following the same user multiple times
}

model Account {
  id                String  @id @default(uuid()) @db.Uuid
  userId            String  @db.Uuid
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model VerificationToken {
  id      String   @id @default(uuid()) @db.Uuid
  email   String   @unique
  token   String
  expires DateTime
}

model ResetToken {
  id      String   @id @default(uuid()) @db.Uuid
  email   String   @unique
  token   String
  expires DateTime
}

model Post {
  id                 String             @id @default(nanoid())
  title              String?
  slug               String?
  thumbnail          String?             
  content            Bytes?
  createdAt          DateTime           @default(now())
  updatedAt          DateTime           @updatedAt
  author             User               @relation(fields: [authorId], references: [id])
  authorId           String             @db.Uuid
  comments           Comment[]
  votes              Vote[]
  type               PostType
  difficulty         Difficulty?
  companies          String[]           @default([])
  completionDuration Int?
  coins              Int?               @default(0)
  topics             String[]           @default([])
  completionStatus   CompletionStatus[]
  category           PostCategory
  subCategory        SubCategory?
  status             PostStatus         @default(DRAFT)
  viewCount          Int                @default(0)
  Bookmark           Bookmark[]
  Report             Report[]
  collaborators      User[]             @relation("PostCollaborators")
  approvalStatus     PostApprovalStatus @default(PENDING)
  approvalLogs       Json? // Array of approval/rejection logs

  @@unique([id, slug], name: "PostIdSlug")
}

model PostEdit {
  id                 String             @id @default(uuid())
  postId             String
  authorId           String             @db.Uuid
  content            Bytes?
  approvalStatus     PostApprovalStatus @default(PENDING)
  approvalLogs       Json? // Array of approval/rejection logs
  createdAt          DateTime           @default(now())
  updatedAt          DateTime           @updatedAt
  title              String?
  type               PostType
  difficulty         Difficulty?
  companies          String[]           @default([])
  completionDuration Int?
  topics             String[]           @default([])

  @@unique([postId, authorId], name: "postId_authorId") // Ensure postId and authorId combination is unique
}

model Comment {
  id        String           @id @default(uuid()) @db.Uuid
  content   Bytes
  createdAt DateTime         @default(now())
  updatedAt DateTime         @default(now())
  author    User             @relation(fields: [authorId], references: [id])
  authorId  String           @db.Uuid
  post      Post             @relation(fields: [postId], references: [id], onDelete: Cascade)
  postId    String
  votes     CommentVote[]
  parent    Comment?         @relation("CommentReplies", fields: [parentId], references: [id])
  parentId  String?          @db.Uuid
  replies   Comment[]        @relation("CommentReplies")
  mentions  CommentMention[] @relation("CommentMentions")
  reports   Report[]         @relation("CommentReports")

  @@index([postId, parentId]) // For thread queries
  @@index([createdAt]) // For time-based sorting
  @@index([parentId]) // For reply lookups
}

model Vote {
  user   User     @relation(fields: [userId], references: [id])
  userId String   @db.Uuid
  post   Post     @relation(fields: [postId], references: [id], onDelete: Cascade)
  postId String
  type   VoteType

  @@id([userId, postId])
  @@index([postId, type])
}

model CommentVote {
  id        String   @id @default(uuid()) @db.Uuid
  user      User     @relation(fields: [userId], references: [id])
  userId    String   @db.Uuid
  comment   Comment  @relation(fields: [commentId], references: [id], onDelete: Cascade)
  commentId String   @db.Uuid
  type      VoteType

  @@unique([userId, commentId])
  @@index([commentId, type])
}

model CommentMention {
  id        String   @id @default(uuid()) @db.Uuid
  user      User     @relation(fields: [userId], references: [id])
  userId    String   @db.Uuid
  comment   Comment  @relation("CommentMentions", fields: [commentId], references: [id])
  commentId String   @db.Uuid
  createdAt DateTime @default(now())

  @@unique([userId, commentId])
  @@index([commentId])
}

model CompletionStatus {
  id          String   @id @default(uuid()) @db.Uuid
  userId      String   @db.Uuid
  postId      String
  completedAt DateTime @default(now())

  user User @relation(fields: [userId], references: [id])
  post Post @relation(fields: [postId], references: [id])

  @@unique([userId, postId])
}

model Bookmark {
  id     String @id @default(uuid()) @db.Uuid
  userId String @db.Uuid
  postId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  post   Post   @relation(fields: [postId], references: [id], onDelete: Cascade)

  @@unique([userId, postId]) // Ensure a user can only bookmark a post once
}

model Report {
  id         String   @id @default(uuid()) @db.Uuid
  reporter   User     @relation(fields: [reporterId], references: [id])
  reporterId String   @db.Uuid
  post       Post?    @relation(fields: [postId], references: [id])
  postId     String?
  comment    Comment? @relation("CommentReports", fields: [commentId], references: [id])
  commentId  String?  @db.Uuid
  reason     String
  createdAt  DateTime @default(now())
}

model Notification {
  id        String   @id @default(uuid()) @db.Uuid
  userId    String   @db.Uuid
  type      String
  message   String
  isRead    Boolean  @default(false)
  createdAt DateTime @default(now())
  link      String?
  relatedId String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, isRead]) // Index for fetching unread notifications quickly
}
